# Model Optimizers - Meta-Organization Pattern

This directory contains tool-specific modules for model optimization (e.g., fine-tuning, prompt engineering).

## Standard Workflow Stages

Each optimizer tool should follow this four-stage pattern:

### Stage 1: INPUT PROCESSING
**File:** `parsing.md`
**Purpose:** Extract structured data from input files (experiment_summary.md, claude.local.md)
**Outputs:** Parsed data structures ready for processing

### Stage 2: PLANNING / SELECTION
**Files:** `*_selection.md`
**Purpose:** Make decisions and apply algorithms without creating artifacts
**Examples:**
- `directory_name_selection.md` - Algorithm for choosing which parameters to include in directory names
- `strategy_selection.md` - Choose which training strategy to use
- `template_selection.md` - Select appropriate config template

### Stage 3: ARTIFACT CREATION
Two distinct approaches for creating artifacts:

#### Manual Generation
**Files:** `*_generation.md`
**Purpose:** Create files directly (Claude writes the content)
**Examples:**
- `directory_generation.md` - Create run directories using mkdir
- `yaml_generation.md` - Write configuration files directly
- `slurm_generation.md` - Write SLURM scripts directly

#### Script Execution
**File:** `script_execution.md`
**Purpose:** Run external repeatable scripts that generate artifacts
**Examples:**
- Running `setup_finetune.py` to transform setup_finetune.yaml → finetune.yaml + slurm
- Executing data preprocessing scripts
- Invoking tool-specific CLIs

**Key Distinction:** Generation = Claude creates content; Execution = Claude runs external tools

### Stage 4: VERIFICATION
**File:** `validation.md`
**Purpose:** Verify outputs are correct and complete
**Checks:** Files exist, parameters match expectations, paths are valid

## Tool Structure Template

When adding a new optimizer tool, use this structure:

```
optimizers/
└── {tool-name}/
    ├── main.md                      # Tool overview and entry point
    ├── parsing.md                   # Stage 1: Input processing
    ├── {decision}_selection.md      # Stage 2: Planning/decision logic
    ├── {artifact}_generation.md     # Stage 3a: Create files directly
    ├── script_execution.md          # Stage 3b: Run external scripts (if needed)
    └── validation.md                # Stage 4: Verification
```

## Current Tools

### torchtune
Fine-tuning LLMs using torchtune framework.

**Workflow:**
1. `parsing.md` - Extract run configurations from experiment_summary.md
2. `directory_name_selection.md` - Determine directory names based on varying parameters
3. `directory_generation.md` - Create run directories (manual)
4. `yaml_generation.md` - Generate setup_finetune.yaml files (manual)
5. `script_execution.md` - Run setup_finetune.py to generate finetune.yaml and SLURM scripts (external)
6. `validation.md` - Verify parameters match directory names

## Design Principles

**Separation of Concerns:** Selection logic (planning) is separate from creation logic (generation/execution)

**Manual vs External:** Distinguish between files Claude creates directly vs files generated by external scripts

**Reusability:** Generic stage names can be reused across different tools

**Progressive Disclosure:** SKILL.md links to main.md, which links to specific stage files

**Consistency:** All tools follow the same 4-stage pattern for predictable organization

## Future Tools

When adding new optimizers (DSPy, custom trainers, etc.), follow this same pattern:
- Keep the 4-stage structure
- Use the `*_selection.md` naming for decision logic
- Use the `*_generation.md` naming for manual file creation
- Use `script_execution.md` for running external tools
- Document tool-specific details in `main.md`
